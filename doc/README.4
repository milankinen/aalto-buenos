Phase 4 README
=================
Group 3
Lauri Hartikka, 79956E
Jaakko Hujanen, 78842N
Matti Lankinen, 82105H

Assignment 1
--------------------
Modified files:
kernel/exception.c
kernel/interrupt.c
proc/exception.c
proc/process.c
proc/syscall_handler_proc.c
vm/tlb.c
vm/tlb.h
vm/vm.c
vm/vm.h

In the assignment, software driven TLB management was implemented.
The implementation where the TLB was simply filled during the context
switch was removed and in the new implementation the TLB is filled as
the exceptions dynamically occur.

When a TLB specific exception occurs (EXCEPTION_TLBL or EXCEPTION_TLBS)
the TLB filling routine starts, whose implementation is found in the
try_to_fill(int check_dirty) method. The method does the following:

First the TLB entry for the bad address generated by the exception is
acquired using the vm_get_entry_by_vaddr method. Depending on whether
address is on the even or odd page the V0 or V1 and D0 or D1 are checked
accordingly. If the exception was initially a type of store the dirty bit
(D0 or D1) must be checked to be 1 so the writing is legitimate. Finally
the TLB is filled using the random policy and the asid is set.

Also the process starting and exiting  is modified to handle the new TLB
implementation. The tlb_fill call is removed when starting the process
and the process-specific TLB entries are removed when the process is
terminated.


Assignment 2
--------------------
Was not implemented.

Assignment 3 - Malloc and Free
----------------------------------------------
Modified files:
proc/process.h
proc/process_table.h
proc/syscall.c
proc/syscall.h
proc/syscall_handler_proc.c
tests/lib.h
tests/malloc.c
vm/pagepool.c
vm/pagepool.h
vm/vm.c

Test files:
    tests/test_malloc.c
    tests/test_memlimit.c

In this assignment system call memlimit and userland library function
malloc and free were implemented.

For the memlimit function processes and process creation were
updated. Process table now has entry for the lowest heap address,
heap_vaddr, which is an address above elf.rw_addr in such a way that:
1) heap_vaddr does not overlap rw-data and 2) heap_vaddr starts from
the beginning of the page.

To maintain current heap status in the memlimit function a static variable
offset is used. Current heap end can be simply calculated proc.heap_vaddr
+ offset. Offset is updated in memlimit when the argument heap_end is
non-zero and if no errors occur.

Each process will always have one page of heap allocated. This way
memlimit needs to allocate/free only when it is called with argument
heap_end which does not reside on the same page as the current heap
end. Memory allocation is done with vm_map and freeing with vm_unmap
which was also implemented. It zeroes the valid bit of the page and
frees the physical page in which the virtual address was.

Memlimit checks for following errors:
    - argument does not fit in the memory (would overlap stack)
    - argument is under the minimum heap start
    - there are no physical pages left or the pages cannot be mapped
      (this required changing the vm/pagepool.*)

Malloc and free are implemented in tests/malloc.c. Malloc segments
continuous memory into free and used sections, segments. It will look for
a free segment and divide it into used section of wanted size and free
section of the rest of the bytes. If malloc does not find a free space, it
tries to get more with memlimit. The segments start with a header struct
which is used to form a doubly linked list of segment headers and which
contain the size of the data part. Malloc is works the following way:

    1. Initialize malloc. This is run only once.

    2. Adjust argument size to be aligned in memory
        i.e. multiple of 4 and check for bad size.

    3. Find first free space. If not found, use memlimit
        to gain more heap. If it does not work return NULL.

    4. For the found segment, divide it to allocated and free
        part. Update the linked list appropriately.

    5. Return the address after the header. It is the space
        which is considered the allocated space for a program.

Free will use the same data structure as malloc. It finds the segment
header corresponding to address wanted to be freed. The address must be
an address returned by malloc. Then free will mark the header free and
merge the arounding segments if they are also free. Finally free will
check if the freed segment was the last one and only then use memlimit
to back up the heap end:

    1. Find header and mark it free.

    2. Merge surroundings if free.

    3. If freed header was last, decrease heap with memlimit.
